---
phase: 01-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/state/schema.ts
  - src/state/store.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "State file persists a JSON object with schema version, repo snapshots, and notification history"
    - "Atomic writes use temp-file-then-rename so a crash mid-write never corrupts state"
    - "A missing state file causes a warning log and the app continues with empty state"
    - "A corrupt (invalid JSON) state file causes a warning log and the app continues with empty state"
    - "A schema-invalid state file (valid JSON but wrong shape) causes a warning log and the app continues with empty state"
    - "The entry point validates config, initializes logger, loads state, and logs startup completion"
    - "npm run build compiles the full project without errors"
  artifacts:
    - path: "src/state/schema.ts"
      provides: "Zod schema for application state and EMPTY_STATE constant"
      exports: ["stateSchema", "AppState", "EMPTY_STATE"]
    - path: "src/state/store.ts"
      provides: "StateStore class with atomic load/save and graceful recovery"
      exports: ["StateStore"]
    - path: "src/index.ts"
      provides: "Application entry point wiring config, logger, and state"
      contains: "main"
  key_links:
    - from: "src/state/store.ts"
      to: "src/state/schema.ts"
      via: "import stateSchema for validation"
      pattern: "import.*stateSchema.*from.*schema"
    - from: "src/state/store.ts"
      to: "src/logger.ts"
      via: "pino.Logger for structured logging"
      pattern: "pino\\.Logger"
    - from: "src/state/store.ts"
      to: "node:fs/promises"
      via: "writeFile + rename for atomic writes"
      pattern: "rename\\(tempPath"
    - from: "src/index.ts"
      to: "src/state/store.ts"
      via: "StateStore instantiation and load"
      pattern: "new StateStore"
    - from: "src/index.ts"
      to: "src/config.ts"
      via: "config import triggers validation"
      pattern: "import.*config.*from.*config"
---

<objective>
Build crash-safe state persistence and wire together the full application entry point.

Purpose: The state store is the persistence backbone of GitScope -- it must survive crashes, missing files, and corrupt data without losing previously saved state. The entry point proves all infrastructure modules work together: config validates, logger outputs structured JSON, and state loads gracefully.
Output: src/state/schema.ts, src/state/store.ts, and a complete src/index.ts that boots the application.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state schema and atomic state store</name>
  <files>src/state/schema.ts, src/state/store.ts</files>
  <action>
1. Create directory `src/state/` if it does not exist.

2. Create `src/state/schema.ts`:
   - Import `z` from `"zod"`
   - Define `repoSnapshotSchema` as z.object with:
     - `owner: z.string()`
     - `name: z.string()`
     - `description: z.string().nullable()`
     - `topics: z.array(z.string())`
     - `addedAt: z.string()` (ISO timestamp)
     - `snapshots: z.array(z.object({ timestamp: z.string(), stars: z.number(), forks: z.number() }))`
   - Define `notificationRecordSchema` as z.object with:
     - `lastAlertAt: z.string()` (ISO timestamp)
   - Define and export `stateSchema` as z.object with:
     - `meta: z.object({ version: z.number(), lastCycleAt: z.string().nullable() })`
     - `repos: z.record(z.string(), repoSnapshotSchema)`
     - `notifications: z.record(z.string(), notificationRecordSchema)`
   - Export `type AppState = z.infer<typeof stateSchema>`
   - Export `const EMPTY_STATE: AppState` with version: 1, lastCycleAt: null, empty repos and notifications objects

3. Create `src/state/store.ts`:
   - Import `readFile, writeFile, rename` from `"node:fs/promises"`
   - Import `type pino` from `"pino"` (type-only import for the Logger type)
   - Import `type AppState`, `EMPTY_STATE`, `stateSchema` from `"./schema.js"` (NOTE: .js extension for Node16 resolution)
   - Create `export class StateStore` with:
     - Private fields: `state: AppState`, `filePath: string`, `log: pino.Logger`
     - Constructor: takes `filePath: string` and `logger: pino.Logger`, initializes state to spread of EMPTY_STATE
     - `async load(): Promise<void>`:
       - Try to readFile(this.filePath, "utf-8")
       - JSON.parse the content
       - Run stateSchema.safeParse on the parsed object
       - If safeParse succeeds: set this.state = result.data, log.info with filePath
       - If safeParse fails: log.warn with filePath and error issues, set state to EMPTY_STATE copy
       - Catch errors:
         - If err.code === "ENOENT": log.warn "State file not found, starting with empty state"
         - Otherwise: log.warn "State file corrupt or unreadable, starting with empty state" (handles invalid JSON, permission errors)
         - In all catch cases: set state to EMPTY_STATE copy
     - `async save(): Promise<void>`:
       - Build tempPath as `${this.filePath}.${process.pid}.tmp` (same directory as target -- CRITICAL to avoid EXDEV cross-device errors per Research Pitfall #5)
       - JSON.stringify(this.state, null, 2) for readable output
       - writeFile(tempPath, content, "utf-8")
       - rename(tempPath, this.filePath) -- this is the atomic operation
       - log.debug with filePath "State saved atomically"
     - `getState(): AppState` -- returns this.state
     - `updateState(updater: (state: AppState) => void): void` -- calls updater(this.state) for in-place mutation. This is a convenience method for Phase 2 callers.
  </action>
  <verify>
- `npm run build` compiles without errors
- `ls dist/state/schema.js dist/state/store.js` both exist
- `grep "rename" src/state/store.ts` confirms atomic write pattern
- `grep "safeParse" src/state/store.ts` confirms schema validation on load
- `grep "ENOENT" src/state/store.ts` confirms missing-file handling
  </verify>
  <done>src/state/schema.ts defines the full state shape with zod and exports AppState type + EMPTY_STATE. src/state/store.ts provides StateStore class with atomic save (temp+rename), graceful load (handles missing, corrupt JSON, invalid schema), and structured logging throughout.</done>
</task>

<task type="auto">
  <name>Task 2: Wire entry point and verify full build</name>
  <files>src/index.ts</files>
  <action>
1. Replace the stub `src/index.ts` (created in Plan 01) with the full entry point:
   - Import `config` from `"./config.js"` (this import triggers config validation -- if env vars are missing, process exits before reaching any other code)
   - Import `createLogger` from `"./logger.js"`
   - Import `StateStore` from `"./state/store.js"`
   - Create main logger: `const log = createLogger("main")`
   - Define `async function main(): Promise<void>`:
     - `log.info("GitScope starting")`
     - Create StateStore: `const store = new StateStore(config.STATE_FILE_PATH, createLogger("state"))`
     - `await store.load()`
     - Access the state to verify it loaded: `const state = store.getState()`
     - `log.info({ repoCount: Object.keys(state.repos).length, version: state.meta.version }, "GitScope initialized successfully")`
     - Comment: `// Phase 2 will add: GitHub client init, Telegram bot init, scheduler start`
   - Call main() with `.catch((err) => { console.error("Fatal startup error:", err); process.exit(1); })`

2. Run `npm run build` and verify clean compilation:
   - `npm run build` must exit 0
   - All .js files in dist/ must be present: index.js, config.js, logger.js, state/schema.js, state/store.js

3. Create a `.env.example` file documenting required environment variables (do NOT create an actual .env with real tokens):
   ```
   # Required
   GITHUB_TOKEN=ghp_your_fine_grained_token_here
   TELEGRAM_BOT_TOKEN=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
   TELEGRAM_CHAT_ID=-1001234567890

   # Optional (defaults shown)
   STATE_FILE_PATH=./state.json
   LOG_LEVEL=info
   ```

4. Verify error behavior: Run `node dist/index.js` WITHOUT an .env file. Confirm it prints error messages naming the missing variables and exits non-zero.

5. Verify success behavior: Run with dummy env vars:
   `GITHUB_TOKEN=test TELEGRAM_BOT_TOKEN=test TELEGRAM_CHAT_ID=test node dist/index.js`
   Confirm it outputs structured JSON logs showing "GitScope starting" and "GitScope initialized successfully" with module names and timestamps, then exits cleanly (no scheduler running yet, so main() completes).
  </action>
  <verify>
- `npm run build` exits 0 with no errors
- `ls dist/index.js dist/config.js dist/logger.js dist/state/schema.js dist/state/store.js` all exist
- `node dist/index.js 2>&1; echo "exit: $?"` shows config validation errors and exits non-zero
- `GITHUB_TOKEN=test TELEGRAM_BOT_TOKEN=test TELEGRAM_CHAT_ID=test node dist/index.js 2>&1` shows JSON log lines with "GitScope starting" and "GitScope initialized successfully" containing timestamps and module fields
- `cat .env.example` documents all required and optional env vars
  </verify>
  <done>src/index.ts wires config, logger, and state store into a working entry point. The full project compiles, rejects missing env vars with clear errors, loads state gracefully, and produces structured JSON logs. .env.example documents the required configuration.</done>
</task>

</tasks>

<verification>
1. `npm run build` exits 0 -- full TypeScript compilation with strict mode
2. `node dist/index.js` without env vars prints clear errors naming each missing variable and exits non-zero
3. `GITHUB_TOKEN=x TELEGRAM_BOT_TOKEN=x TELEGRAM_CHAT_ID=x node dist/index.js` outputs structured JSON logs with timestamps, module names, and contextual data
4. Create a test state file with invalid JSON, run the app -- it logs a warning and continues with empty state
5. Delete the state file, run the app -- it logs a warning about missing file and continues
6. Create a valid state file, run the app -- it loads successfully and logs the repo count
</verification>

<success_criteria>
- State schema defines version, repo snapshots (with star counts), and notification history
- State writes are atomic (temp file + rename pattern)
- Missing state file: warning logged, app continues with empty state
- Corrupt state file: warning logged, app continues with empty state
- Entry point orchestrates config -> logger -> state in correct order
- Full project compiles and runs end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md`
</output>
