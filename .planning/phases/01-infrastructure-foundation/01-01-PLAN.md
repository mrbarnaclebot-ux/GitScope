---
phase: 01-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .gitignore
  - src/config.ts
  - src/logger.ts
autonomous: true

must_haves:
  truths:
    - "npm install completes without errors and all required dependencies are present in node_modules"
    - "npm run build compiles TypeScript with strict mode and produces output in dist/"
    - "Starting the app with missing GITHUB_TOKEN fails immediately with a clear error naming the variable"
    - "Starting the app with missing TELEGRAM_BOT_TOKEN fails immediately with a clear error naming the variable"
    - "Starting the app with missing TELEGRAM_CHAT_ID fails immediately with a clear error naming the variable"
    - "Log output from createLogger is structured JSON with timestamps and module names"
    - "state.json is in .gitignore and will not be committed"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with dependencies and scripts"
      contains: "grammy"
    - path: "tsconfig.json"
      provides: "TypeScript configuration with strict mode and Node16 module resolution"
      contains: "strict"
    - path: "src/config.ts"
      provides: "Zod-validated environment config with fail-fast behavior"
      exports: ["config", "Config"]
    - path: "src/logger.ts"
      provides: "Pino-based structured logger factory"
      exports: ["createLogger"]
  key_links:
    - from: "src/config.ts"
      to: "process.env"
      via: "zod safeParse"
      pattern: "envSchema\\.safeParse\\(process\\.env\\)"
    - from: "src/logger.ts"
      to: "pino"
      via: "rootLogger.child()"
      pattern: "rootLogger\\.child"
---

<objective>
Initialize the GitScope project with TypeScript tooling, validated configuration, and structured logging.

Purpose: Establish the build system, dependency tree, and two foundational modules (config validation, structured logging) that every subsequent module depends on. Without a working build and validated config, nothing else can be tested.
Output: A compilable TypeScript project with package.json, tsconfig.json, updated .gitignore, src/config.ts, and src/logger.ts.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TypeScript project with dependencies and build tooling</name>
  <files>package.json, tsconfig.json, .gitignore</files>
  <action>
1. Run `npm init -y` in the project root to create package.json.

2. Edit package.json to set:
   - `"name": "gitscope"`
   - `"type": "module"` (required for ESM imports with Node16 module resolution)
   - `"engines": { "node": ">=22.0.0" }`
   - Scripts:
     - `"build": "tsc"`
     - `"start": "node --env-file=.env dist/index.js"`
     - `"dev": "tsx --env-file=.env --watch src/index.ts"`
     - `"dev:pretty": "tsx --env-file=.env src/index.ts | npx pino-pretty"`

3. Install production dependencies: `npm install grammy @octokit/rest node-cron zod pino`

4. Install dev dependencies: `npm install -D typescript tsx @types/node pino-pretty`

5. Create tsconfig.json:
   ```json
   {
     "compilerOptions": {
       "target": "ES2022",
       "module": "Node16",
       "moduleResolution": "Node16",
       "outDir": "dist",
       "rootDir": "src",
       "strict": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "declaration": true,
       "sourceMap": true
     },
     "include": ["src"]
   }
   ```
   CRITICAL: Must use `"module": "Node16"` and `"moduleResolution": "Node16"` -- NOT "bundler" or "ESNext". @octokit/rest v22 uses package.json conditional exports which require Node16 resolution. Research Pitfall #1 confirms this.

6. Add `state.json` to .gitignore. The existing .gitignore already has `.env` but is MISSING `state.json` (confirmed by research). Append to the end of the file:
   ```
   # Application state
   state.json
   state.json.*.tmp
   ```
   Also ensure `dist/` is covered (it already appears as `dist` in the existing .gitignore, which matches the directory).

7. Create the `src/` directory if it does not exist.
  </action>
  <verify>
- `npm run build` succeeds (may warn about no input files, which is fine -- src/index.ts comes in Task 2 of this plan)
- `cat tsconfig.json | grep '"strict": true'` confirms strict mode
- `cat tsconfig.json | grep '"module": "Node16"'` confirms correct module setting
- `cat package.json | grep '"type": "module"'` confirms ESM
- `grep "state.json" .gitignore` confirms state file exclusion
- `ls node_modules/grammy node_modules/@octokit/rest node_modules/node-cron node_modules/zod node_modules/pino` all exist
  </verify>
  <done>package.json has correct scripts/engines/type, tsconfig.json has strict+Node16, .gitignore includes state.json, all 5 production deps and 4 dev deps installed</done>
</task>

<task type="auto">
  <name>Task 2: Create config validation and structured logger modules</name>
  <files>src/config.ts, src/logger.ts</files>
  <action>
1. Create `src/config.ts`:
   - Import `z` from `"zod"` (zod v4 -- do NOT use v3 patterns like errorMap)
   - Define `envSchema` as `z.object({...})` with:
     - `GITHUB_TOKEN: z.string().min(1, "GITHUB_TOKEN is required")`
     - `TELEGRAM_BOT_TOKEN: z.string().min(1, "TELEGRAM_BOT_TOKEN is required")`
     - `TELEGRAM_CHAT_ID: z.string().min(1, "TELEGRAM_CHAT_ID is required")`
     - `STATE_FILE_PATH: z.string().default("./state.json")`
     - `LOG_LEVEL: z.enum(["trace", "debug", "info", "warn", "error", "fatal"]).default("info")`
   - Export `type Config = z.infer<typeof envSchema>`
   - Create `loadConfig()` function that:
     - Calls `envSchema.safeParse(process.env)`
     - On failure: prints each issue with `console.error()` (NOT pino -- pino is not initialized yet, and console.error is synchronous so it flushes before exit; see Research Pitfall #6), then calls `process.exit(1)`
     - On success: returns `result.data`
   - Export `const config = loadConfig()` (eagerly validates on import)

2. Create `src/logger.ts`:
   - Import `pino` from `"pino"`
   - Import `config` from `"./config.js"` (NOTE: `.js` extension required for Node16 module resolution even though source is .ts)
   - Create root logger: `pino({ level: config.LOG_LEVEL, timestamp: pino.stdTimeFunctions.isoTime })`
   - Export `function createLogger(module: string): pino.Logger` that returns `rootLogger.child({ module })`
   - Do NOT configure pino-pretty as an inline transport (Research Pitfall #4). Pino-pretty is used via pipe in dev:pretty script only.

3. Verify the build compiles:
   - Create a minimal `src/index.ts` stub: `import { config } from "./config.js"; import { createLogger } from "./logger.js"; const log = createLogger("main"); log.info("GitScope placeholder");`
   - Run `npm run build` and confirm it compiles to dist/ without errors
   - This stub will be replaced by Plan 02 with the full entry point
  </action>
  <verify>
- `npm run build` completes with exit code 0
- `ls dist/config.js dist/logger.js dist/index.js` all exist
- `node -e "import('./dist/config.js').catch(e => { console.log('Expected: config validation error'); console.log(e.message || 'exit'); })"` -- running without env vars causes a config validation failure (process.exit in loadConfig)
- `grep -c "safeParse" src/config.ts` returns >= 1
- `grep -c "child" src/logger.ts` returns >= 1
  </verify>
  <done>src/config.ts validates env vars with zod and fails fast with clear error messages. src/logger.ts provides createLogger factory producing structured JSON logs with timestamps and module names. npm run build compiles all files to dist/ without errors.</done>
</task>

</tasks>

<verification>
1. `npm run build` exits 0 and produces dist/config.js, dist/logger.js, dist/index.js
2. Running `node dist/index.js` without env vars prints clear error messages naming missing variables and exits non-zero
3. Running with env vars set (even dummy values) produces structured JSON log output to stdout
4. `grep "state.json" .gitignore` shows state file is excluded
5. `cat tsconfig.json` shows strict: true, module: Node16, moduleResolution: Node16
</verification>

<success_criteria>
- TypeScript project builds with strict mode on Node16 module resolution
- All 5 production dependencies (grammy, @octokit/rest, node-cron, zod, pino) installed
- Config validation rejects missing env vars with clear per-variable error messages
- Logger produces JSON output with timestamps, levels, and module names
- .gitignore covers state.json and .env
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md`
</output>
