---
phase: 03-notification-reliability-deployment
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/monitor/cycle.ts
autonomous: true

must_haves:
  truths:
    - "The same repo is not re-alerted within the cooldown period (default 7 days)"
    - "Deduplication state (notifications record) is written after successful delivery and persists across restarts"
    - "When more than BATCH_THRESHOLD repos trend simultaneously, a single digest message is sent instead of individual alerts"
    - "When BATCH_THRESHOLD or fewer repos trend, individual alerts are sent as before"
  artifacts:
    - path: "src/monitor/cycle.ts"
      provides: "Deduplication-aware, batch-capable monitoring cycle"
      contains: "isWithinCooldown"
  key_links:
    - from: "src/monitor/cycle.ts"
      to: "state.notifications"
      via: "cooldown check before send, record write after successful send"
      pattern: "notifications\\[.*\\]"
    - from: "src/monitor/cycle.ts"
      to: "formatDigest"
      via: "import and call when pendingAlerts.length > batchThreshold"
      pattern: "formatDigest"
    - from: "src/monitor/cycle.ts"
      to: "config.COOLDOWN_DAYS"
      via: "function parameter for cooldown check"
      pattern: "cooldownDays"
    - from: "src/monitor/cycle.ts"
      to: "config.BATCH_THRESHOLD"
      via: "function parameter for batch branching"
      pattern: "batchThreshold"
---

<objective>
Restructure the monitoring cycle to check deduplication cooldowns before alerting, collect alerts into an array, and branch to digest format when the count exceeds the batch threshold.

Purpose: This is the integration plan that wires deduplication and batching into the core cycle loop. Without this, the sender reliability (Plan 01) and digest formatter (Plan 02) exist but are unused. This plan makes them operational.
Output: Fully restructured cycle.ts with deduplication and batching.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-notification-reliability-deployment/03-RESEARCH.md
@.planning/phases/03-notification-reliability-deployment/03-01-SUMMARY.md
@.planning/phases/03-notification-reliability-deployment/03-02-SUMMARY.md
@src/monitor/cycle.ts
@src/config.ts
@src/telegram/formatter.ts
@src/state/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deduplication check and restructure cycle for collect-then-send</name>
  <files>src/monitor/cycle.ts</files>
  <action>
Restructure `runMonitoringCycle` in `src/monitor/cycle.ts`. The function signature changes to accept `cooldownDays` and `batchThreshold` as parameters (numbers). The caller in `index.ts` will pass `config.COOLDOWN_DAYS` and `config.BATCH_THRESHOLD`.

**Updated function signature:**
```typescript
export async function runMonitoringCycle(
  github: GitHubClient,
  telegram: TelegramSender,
  store: StateStore,
  keywords: string[],
  cooldownDays: number,
  batchThreshold: number,
): Promise<void>
```

**Step 1: Add `isWithinCooldown` helper (module-level, not exported):**

```typescript
function isWithinCooldown(
  state: AppState,
  repoKey: string,
  cooldownDays: number,
): boolean {
  const record = state.notifications[repoKey];
  if (!record) return false;
  const lastAlert = new Date(record.lastAlertAt);
  const cooldownMs = cooldownDays * 24 * 60 * 60 * 1000;
  return Date.now() - lastAlert.getTime() < cooldownMs;
}
```

Import `AppState` type from `../state/schema.js`.

**Step 2: Define `PendingAlert` interface (module-level):**

```typescript
interface PendingAlert {
  repoKey: string;
  message: string;
  digestEntry: DigestEntry;
}
```

Import `DigestEntry` and `formatDigest` from `../telegram/formatter.js`.

**Step 3: Restructure the repo loop to COLLECT instead of SEND:**

In the existing repo loop, replace the `telegram.send()` calls with pushes to a `pendingAlerts` array. Before pushing, check `isWithinCooldown()`:

For each repo:
1. Calculate velocity (unchanged)
2. Determine if alert is needed (unchanged logic for new repos and velocity tiers)
3. **NEW: Check cooldown** -- if `isWithinCooldown(store.getState(), key, cooldownDays)`, skip this repo and log at debug level: "Repo within cooldown, skipping alert"
4. If NOT in cooldown and alert is needed, build the message string (unchanged) and create a `DigestEntry`, then push both to `pendingAlerts`
5. Update state snapshots (unchanged -- this still happens per-repo in the loop)

**DigestEntry construction:**
- For velocity alerts: `{ owner, name, stars, starsPerDay: velocity.starsPerDay, tier }`
- For new repo alerts: `{ owner, name, stars, starsPerDay: 0, tier: "new" as const }`

**Step 4: After the repo loop, send alerts using batch-or-individual strategy:**

```typescript
if (pendingAlerts.length > batchThreshold) {
  // Digest mode: single message
  const digest = formatDigest(pendingAlerts.map((a) => a.digestEntry));
  const sent = await telegram.send(digest);
  if (sent) {
    // Write notification records for ALL repos in the digest
    for (const alert of pendingAlerts) {
      store.updateState((s) => {
        s.notifications[alert.repoKey] = { lastAlertAt: new Date().toISOString() };
      });
    }
    alertCount = pendingAlerts.length;
    log.info({ alertCount }, "Digest alert sent");
  }
} else {
  // Individual mode: one message per repo
  for (const alert of pendingAlerts) {
    const sent = await telegram.send(alert.message);
    if (sent) {
      alertCount++;
      store.updateState((s) => {
        s.notifications[alert.repoKey] = { lastAlertAt: new Date().toISOString() };
      });
      log.info({ repo: alert.repoKey }, "Individual alert sent");
    }
  }
}
```

**CRITICAL:** Write the notification record (`s.notifications[key] = { lastAlertAt: ... }`) ONLY after `telegram.send()` returns `true`. This prevents suppressing alerts that were never actually delivered.

**Step 5: Update the caller in `src/index.ts`:**

The `cycle` closure in `index.ts` currently passes 4 args. Update it to pass 6:

```typescript
const cycle = () => runMonitoringCycle(
  github, telegram, store, config.MONITOR_KEYWORDS,
  config.COOLDOWN_DAYS, config.BATCH_THRESHOLD,
);
```

This is a one-line change in `index.ts`.

The rest of the cycle function (search, state snapshots update, cycle metadata update, store.save()) remains unchanged.
  </action>
  <verify>
1. `npm run build` succeeds with zero errors
2. `grep -q "isWithinCooldown" src/monitor/cycle.ts` confirms deduplication logic
3. `grep -q "formatDigest" src/monitor/cycle.ts` confirms digest import and usage
4. `grep -q "batchThreshold" src/monitor/cycle.ts` confirms batch branching
5. `grep -q "notifications\[" src/monitor/cycle.ts` (or similar) confirms notification record writes
6. `grep -q "COOLDOWN_DAYS" src/index.ts` confirms caller passes config values
  </verify>
  <done>
cycle.ts checks isWithinCooldown before alerting, collects alerts into pendingAlerts array, branches to digest when count > batchThreshold, sends individual alerts otherwise. Notification records are written ONLY after successful delivery. index.ts passes COOLDOWN_DAYS and BATCH_THRESHOLD to the cycle function. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with zero errors
2. Full flow trace: Search -> velocity/classify -> cooldown check -> collect pending -> batch-or-individual send -> write notification record -> save state
3. Dedup: `isWithinCooldown` reads from `state.notifications[key].lastAlertAt` and compares against `cooldownDays * 86400000`
4. Batch: `pendingAlerts.length > batchThreshold` triggers `formatDigest` path
5. Record write: `s.notifications[key] = { lastAlertAt: ... }` occurs inside `if (sent)` block only
6. No regression: state snapshot updates and cycle metadata unchanged
</verification>

<success_criteria>
- Repos within cooldown period are skipped (not alerted) with debug log
- Repos outside cooldown get alerted and their notification record is written after successful delivery
- When pending alerts exceed BATCH_THRESHOLD, a single digest message is sent
- When pending alerts are at or below BATCH_THRESHOLD, individual messages are sent
- index.ts passes COOLDOWN_DAYS and BATCH_THRESHOLD from config to cycle
- TypeScript builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-notification-reliability-deployment/03-03-SUMMARY.md`
</output>
