---
phase: 02-monitoring-alerting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/monitor/velocity.ts
  - src/monitor/classifier.ts
  - src/telegram/formatter.ts
  - src/telegram/sender.ts
autonomous: true

must_haves:
  truths:
    - "Velocity calculation detects stars/day from consecutive snapshots and handles first-sighting (no previous snapshot) as a special case"
    - "Severity classifier assigns notable/hot/viral tiers using base threshold multipliers (1x/3x/10x) with age-dependent base thresholds (5 stars/day for young repos, 10 for older)"
    - "Telegram alerts are HTML-formatted with repo name linked, star count, velocity delta, description, language, and age"
    - "All user-provided strings in alerts are HTML-escaped to prevent parse errors"
  artifacts:
    - path: "src/monitor/velocity.ts"
      provides: "Star velocity calculation from snapshot deltas"
      exports: ["calculateVelocity", "VelocityResult"]
    - path: "src/monitor/classifier.ts"
      provides: "Severity tier classification with configurable thresholds"
      exports: ["classifySeverity", "SeverityTier", "THRESHOLD_CONFIG"]
    - path: "src/telegram/formatter.ts"
      provides: "HTML alert message builder with escaping"
      exports: ["formatAlert", "AlertData"]
    - path: "src/telegram/sender.ts"
      provides: "grammY API wrapper for sending alerts"
      exports: ["createTelegramSender", "TelegramSender"]
  key_links:
    - from: "src/monitor/classifier.ts"
      to: "src/monitor/velocity.ts"
      via: "classifier uses VelocityResult.starsPerDay and repoAgeDays"
      pattern: "starsPerDay.*repoAgeDays"
    - from: "src/telegram/formatter.ts"
      to: "src/monitor/classifier.ts"
      via: "formatter uses SeverityTier type for tier display"
      pattern: "SeverityTier"
    - from: "src/telegram/sender.ts"
      to: "grammy"
      via: "bot.api.sendMessage with parse_mode HTML"
      pattern: "sendMessage.*parse_mode.*HTML"
---

<objective>
Create the business logic and Telegram alert layer: velocity calculation, severity classification, HTML alert formatting, and Telegram message sending.

Purpose: These are the pure business logic modules and the Telegram output channel -- self-contained modules that the monitoring cycle will orchestrate. Velocity and classifier implement the core detection logic (MON-02, MON-03, MON-04). Formatter and sender implement the notification output (NOTF-01).
Output: Four modules with clean interfaces ready for the cycle orchestrator to compose.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-monitoring-alerting/02-RESEARCH.md
@src/config.ts
@src/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create velocity calculator and severity classifier</name>
  <files>
    src/monitor/velocity.ts
    src/monitor/classifier.ts
  </files>
  <action>
1. Create `src/monitor/velocity.ts`:
   - Export interface `VelocityResult` with fields: starsPerDay (number), isNew (boolean -- true if no previous snapshot exists), repoAgeDays (number), currentStars (number), previousStars (number)
   - Export function `calculateVelocity(currentStars: number, createdAt: string, lastSnapshot: { stars: number; timestamp: string } | null, now?: Date): VelocityResult`
   - Implementation:
     - Calculate repoAgeDays from createdAt ISO string to now
     - If lastSnapshot is null: return { starsPerDay: 0, isNew: true, repoAgeDays, currentStars, previousStars: 0 } -- first sighting, cannot calculate velocity
     - Calculate hoursSinceSnapshot from lastSnapshot.timestamp to now
     - Guard against division by near-zero: if hoursSinceSnapshot < 0.1, return starsPerDay: 0
     - starsPerDay = ((currentStars - lastSnapshot.stars) / hoursSinceSnapshot) * 24
     - Return full VelocityResult with isNew: false
   - The `now` parameter defaults to `new Date()` for testability

2. Create `src/monitor/classifier.ts`:
   - Export type `SeverityTier = "notable" | "hot" | "viral"`
   - Export interface `ThresholdConfig` with fields: youngRepoMaxAgeDays (number), youngRepoMinVelocity (number), oldRepoMinVelocity (number), newRepoMinStars (number), hotMultiplier (number), viralMultiplier (number)
   - Export const `THRESHOLD_CONFIG: ThresholdConfig` with defaults: youngRepoMaxAgeDays: 30, youngRepoMinVelocity: 5, oldRepoMinVelocity: 10, newRepoMinStars: 20, hotMultiplier: 3, viralMultiplier: 10
   - Export function `classifySeverity(starsPerDay: number, repoAgeDays: number, config?: ThresholdConfig): SeverityTier | null`
     - Uses config or defaults to THRESHOLD_CONFIG
     - Determine base threshold: if repoAgeDays < config.youngRepoMaxAgeDays, use youngRepoMinVelocity (5), else oldRepoMinVelocity (10)
     - If starsPerDay < threshold, return null (no alert)
     - If starsPerDay >= threshold * viralMultiplier (10x), return "viral"
     - If starsPerDay >= threshold * hotMultiplier (3x), return "hot"
     - Otherwise return "notable"
   - Export function `shouldAlertNewRepo(stars: number, config?: ThresholdConfig): boolean`
     - Returns true if stars >= config.newRepoMinStars (default 20)
     - Used for first-sighting detection (MON-03)
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm both files compile. Verify exports: `grep -n "export" src/monitor/velocity.ts src/monitor/classifier.ts` should show calculateVelocity, VelocityResult, classifySeverity, SeverityTier, ThresholdConfig, THRESHOLD_CONFIG, shouldAlertNewRepo.
  </verify>
  <done>
    velocity.ts exports calculateVelocity with first-sighting handling and division-by-zero guard. classifier.ts exports classifySeverity with age-dependent thresholds and 3 tiers, plus shouldAlertNewRepo for MON-03. Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Telegram formatter and sender</name>
  <files>
    src/telegram/formatter.ts
    src/telegram/sender.ts
  </files>
  <action>
1. Create `src/telegram/formatter.ts`:
   - Export function `escapeHtml(text: string): string` -- replaces & with &amp;, < with &lt;, > with &gt;, " with &quot; (in that order -- & first to avoid double-escaping)
   - Export interface `AlertData` with fields: owner (string), name (string), description (string | null), stars (number), starsPerDay (number), language (string | null), repoAgeDays (number), tier (SeverityTier) -- import SeverityTier from ../monitor/classifier.js
   - Export function `formatAlert(data: AlertData): string` that builds an HTML message:
     ```
     {tierEmoji} <b>[{TIER}]</b> <a href="https://github.com/{owner}/{name}">{owner}/{name}</a>
     Stars: <b>{stars}</b> (+{starsPerDay}/day)
     {description or "<i>No description</i>"}
     Language: {language or "N/A"} | Age: {formatted age}
     ```
     - Tier emojis: notable = star, hot = fire, viral = rocket (use actual unicode: \u2b50, \ud83d\udd25, \ud83d\ude80)
     - Age formatting: < 1 day = "< 1 day", < 30 days = "{N} days", >= 30 days = "{N} months"
     - All user-provided strings (owner, name, description) MUST be passed through escapeHtml()
     - starsPerDay formatted with toFixed(1)
   - Export function `formatNewRepoAlert(data: Omit<AlertData, "starsPerDay" | "tier">): string` for first-sighting alerts (MON-03):
     ```
     {new emoji} <b>[NEW]</b> <a href="...">{owner}/{name}</a>
     Stars: <b>{stars}</b>
     {description}
     Language: {language} | Age: {age}
     ```
     - Use \ud83c\udd95 (NEW button emoji) or \u2728 (sparkles)

2. Create `src/telegram/sender.ts`:
   - Import `Bot`, `GrammyError`, `HttpError` from "grammy"
   - Import `createLogger` from "../logger.js"
   - Export interface `TelegramSender` with method `send(message: string): Promise<boolean>`
   - Export function `createTelegramSender(botToken: string, chatId: string): TelegramSender`
     - Creates `new Bot(botToken)` -- do NOT call bot.start(), just use bot.api
     - Returns object implementing TelegramSender:
       - `send(message)`: calls `bot.api.sendMessage(chatId, message, { parse_mode: "HTML" })`
       - On success: log info and return true
       - On GrammyError: log error with err.description, return false
       - On HttpError: log error, return false
       - On unknown error: log error, return false (do NOT re-throw -- alerts should not crash the cycle)
     - Uses `createLogger("telegram")` for logging
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm both files compile. Verify exports: `grep -n "export" src/telegram/formatter.ts src/telegram/sender.ts` should show escapeHtml, AlertData, formatAlert, formatNewRepoAlert, TelegramSender, createTelegramSender.
  </verify>
  <done>
    formatter.ts exports escapeHtml, formatAlert (HTML with all required fields), and formatNewRepoAlert (MON-03). sender.ts exports createTelegramSender with GrammyError/HttpError handling and no bot.start() call. Both compile cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all 4 new files
2. Velocity calculator handles: normal delta, first-sighting (isNew=true), near-zero time interval
3. Classifier returns null for below-threshold, "notable" for 1x, "hot" for 3x, "viral" for 10x
4. shouldAlertNewRepo returns true for stars >= 20
5. Formatter produces valid Telegram HTML with escaped user content
6. Sender wraps bot.api.sendMessage with error handling, never calls bot.start()
</verification>

<success_criteria>
All 4 modules compile cleanly and export the interfaces needed by the cycle orchestrator. Velocity, classification, formatting, and sending are each independently testable with clear contracts.
</success_criteria>

<output>
After completion, create `.planning/phases/02-monitoring-alerting/02-02-SUMMARY.md`
</output>
