---
phase: 02-monitoring-alerting
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/monitor/cycle.ts
  - src/scheduler.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "A single monitoring cycle searches GitHub, calculates velocity for each result, classifies severity, sends alerts for qualifying repos, updates state snapshots, and saves state atomically"
    - "The scheduler runs the cycle every 30 minutes via node-cron with noOverlap: true preventing concurrent cycles"
    - "The entry point initializes GitHub client, Telegram sender, state store, and scheduler -- the bot runs end to end"
    - "Snapshot arrays are pruned to the last 48 entries per repo to prevent unbounded state growth"
    - "First-sighting repos with >=20 stars trigger a NEW alert even without velocity data"
  artifacts:
    - path: "src/monitor/cycle.ts"
      provides: "Monitoring cycle orchestrator"
      exports: ["runMonitoringCycle"]
    - path: "src/scheduler.ts"
      provides: "Cron scheduler with overlap protection"
      exports: ["startScheduler"]
    - path: "src/index.ts"
      provides: "Fully wired application entry point"
      contains: "startScheduler"
  key_links:
    - from: "src/monitor/cycle.ts"
      to: "src/github/search.ts"
      via: "calls searchRepos to get matching repos"
      pattern: "searchRepos"
    - from: "src/monitor/cycle.ts"
      to: "src/monitor/velocity.ts"
      via: "calls calculateVelocity for each repo"
      pattern: "calculateVelocity"
    - from: "src/monitor/cycle.ts"
      to: "src/monitor/classifier.ts"
      via: "calls classifySeverity and shouldAlertNewRepo"
      pattern: "classifySeverity|shouldAlertNewRepo"
    - from: "src/monitor/cycle.ts"
      to: "src/telegram/formatter.ts"
      via: "calls formatAlert or formatNewRepoAlert to build message"
      pattern: "formatAlert|formatNewRepoAlert"
    - from: "src/monitor/cycle.ts"
      to: "src/telegram/sender.ts"
      via: "calls sender.send() to deliver alert"
      pattern: "sender\\.send"
    - from: "src/monitor/cycle.ts"
      to: "src/state/store.ts"
      via: "updates repo snapshots and saves state"
      pattern: "store\\.updateState|store\\.save"
    - from: "src/scheduler.ts"
      to: "node-cron"
      via: "cron.schedule with noOverlap: true"
      pattern: "noOverlap.*true"
    - from: "src/index.ts"
      to: "src/scheduler.ts"
      via: "calls startScheduler to begin monitoring"
      pattern: "startScheduler"
---

<objective>
Create the monitoring cycle orchestrator, cron scheduler, and wire everything into the entry point -- completing the end-to-end monitoring pipeline.

Purpose: This plan connects all the pieces from Plans 01 and 02 into a working system. The cycle orchestrates search->velocity->classify->format->send->save. The scheduler runs it on a 30-minute cron. The entry point wires GitHub client, Telegram sender, state store, and scheduler together.
Output: A fully functional monitoring bot that searches GitHub every 30 minutes, detects trending repos, and sends formatted Telegram alerts.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-monitoring-alerting/02-RESEARCH.md
@.planning/phases/02-monitoring-alerting/02-01-SUMMARY.md
@.planning/phases/02-monitoring-alerting/02-02-SUMMARY.md
@src/config.ts
@src/state/store.ts
@src/state/schema.ts
@src/index.ts
@src/github/client.ts
@src/github/search.ts
@src/monitor/velocity.ts
@src/monitor/classifier.ts
@src/telegram/formatter.ts
@src/telegram/sender.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create monitoring cycle orchestrator</name>
  <files>
    src/monitor/cycle.ts
  </files>
  <action>
Create `src/monitor/cycle.ts` that orchestrates a single monitoring cycle:

1. Import all dependencies:
   - `searchRepos`, `SearchResult` from "../github/search.js"
   - `calculateVelocity` from "./velocity.js"
   - `classifySeverity`, `shouldAlertNewRepo`, `THRESHOLD_CONFIG` from "./classifier.js"
   - `formatAlert`, `formatNewRepoAlert` from "../telegram/formatter.js"
   - `TelegramSender` from "../telegram/sender.js"
   - `StateStore` from "../state/store.js"
   - `GitHubClient` from "../github/client.js"
   - `createLogger` from "../logger.js"

2. Export `async function runMonitoringCycle(github: GitHubClient, telegram: TelegramSender, store: StateStore, keywords: string[]): Promise<void>`

3. Implementation flow:
   a. **Search**: Call `searchRepos(github, keywords)`. Log result count.
   b. **Process each repo** (for...of loop, NOT parallel -- respect rate limits and Telegram flood limits):
      - Build repo key as `${repo.owner}/${repo.name}`
      - Get existing repo data from `store.getState().repos[key]`
      - Get lastSnapshot: `existing?.snapshots.at(-1) ?? null`
      - Call `calculateVelocity(repo.stars, repo.createdAt, lastSnapshot)`
      - **Determine if alert needed:**
        - If `velocity.isNew && shouldAlertNewRepo(repo.stars)`: format with `formatNewRepoAlert`, send, log
        - Else if NOT isNew: call `classifySeverity(velocity.starsPerDay, velocity.repoAgeDays)`, if tier is not null: format with `formatAlert`, send, log
      - **Update state** via `store.updateState()`:
        - If repo key doesn't exist in state.repos, create it with: owner, name, description, language (from search result), topics, addedAt: new Date().toISOString(), snapshots: []
        - Push new snapshot: { timestamp: new Date().toISOString(), stars: repo.stars, forks: repo.forks }
        - **Prune snapshots**: if snapshots.length > 48, slice to keep only the last 48 (24 hours at 30-min intervals)
   c. **Update cycle metadata**: `store.updateState(s => { s.meta.lastCycleAt = new Date().toISOString(); })`
   d. **Save state**: `await store.save()`
   e. Log cycle complete with alertCount and repoCount

4. Error handling:
   - Wrap the entire cycle in try/catch. Log errors but do NOT re-throw (the scheduler handles retries).
   - Individual alert send failures (sender.send returns false) should NOT abort the cycle -- continue processing remaining repos.
   - If search fails (throws), log error and return early (no state updates for a failed search).

5. Use `createLogger("monitor:cycle")` for all logging.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm the file compiles. Verify the function imports and uses all expected modules: `grep -c "import" src/monitor/cycle.ts` should show 8 imports.
  </verify>
  <done>
    cycle.ts exports runMonitoringCycle that orchestrates search -> velocity -> classify -> format -> send -> snapshot update -> prune -> save. Individual alert failures don't abort the cycle. Snapshots pruned to last 48.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scheduler and wire entry point</name>
  <files>
    src/scheduler.ts
    src/index.ts
  </files>
  <action>
1. Create `src/scheduler.ts`:
   - Import `cron` from "node-cron" (default import)
   - Import `createLogger` from "./logger.js"
   - Use `createLogger("scheduler")` for logging
   - Export `function startScheduler(cronExpression: string, cycleFn: () => Promise<void>): void`
     - Call `cron.schedule(cronExpression, async () => { ... }, { noOverlap: true, name: "gitscope-monitor" })`
     - NOTE: node-cron v4 TaskFn callback MAY receive a TaskContext but the type might vary. Use a simple `async () => {}` wrapper to avoid type issues. Inside:
       - Log "Monitoring cycle starting"
       - Call `await cycleFn()`
       - Log "Monitoring cycle completed"
       - Catch errors: log "Monitoring cycle failed" with error
     - Listen to the `execution:overlap` event on the returned task: `task.on("execution:overlap", () => { log.warn("Monitoring cycle skipped -- previous cycle still running") })`
     - Log info with cronExpression: "Scheduler started"

2. Update `src/index.ts` to wire everything together:
   - Keep existing imports (config, createLogger, StateStore)
   - Add imports:
     - `createGitHubClient` from "./github/client.js"
     - `createTelegramSender` from "./telegram/sender.js"
     - `runMonitoringCycle` from "./monitor/cycle.js"
     - `startScheduler` from "./scheduler.js"
   - In the `main()` function, AFTER existing state load:
     - Create GitHub client: `const github = createGitHubClient(config.GITHUB_TOKEN)`
     - Create Telegram sender: `const telegram = createTelegramSender(config.TELEGRAM_BOT_TOKEN, config.TELEGRAM_CHAT_ID)`
     - Create cycle function: `const cycle = () => runMonitoringCycle(github, telegram, store, config.MONITOR_KEYWORDS)`
     - Start scheduler: `startScheduler(config.MONITOR_CRON, cycle)`
     - Update the log.info message: "GitScope monitoring started" with { repoCount, version, cronExpression: config.MONITOR_CRON, keywords: config.MONITOR_KEYWORDS.length }
   - Remove the comment "// Phase 2 will add: ..."
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all files compile. Run `npm run build` to produce dist/ output. Verify the scheduler file uses noOverlap: `grep "noOverlap" src/scheduler.ts`. Verify index.ts calls startScheduler: `grep "startScheduler" src/index.ts`.
  </verify>
  <done>
    scheduler.ts exports startScheduler with node-cron noOverlap: true and overlap event logging. index.ts wires GitHub client, Telegram sender, state store, and scheduler into a fully functional entry point. `npm run build` produces clean output.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with zero errors, producing dist/ output
2. cycle.ts orchestrates the full search -> detect -> alert -> save pipeline
3. Snapshots are pruned to last 48 per repo in cycle.ts
4. scheduler.ts uses node-cron v4 `noOverlap: true` with `execution:overlap` event handler
5. index.ts creates GitHub client, Telegram sender, wires to scheduler with config.MONITOR_CRON
6. No call to `bot.start()` anywhere in the codebase
7. The full application can be started with `npm run dev` (will attempt to connect to GitHub and Telegram)
</verification>

<success_criteria>
The monitoring bot compiles cleanly and is fully wired end to end. Starting the bot with valid env vars would begin a 30-minute monitoring cycle that searches GitHub, detects trending repos, and sends formatted Telegram alerts. The system handles rate limits automatically, prevents concurrent cycles, prunes old snapshots, and recovers gracefully from individual alert failures.
</success_criteria>

<output>
After completion, create `.planning/phases/02-monitoring-alerting/02-03-SUMMARY.md`
</output>
